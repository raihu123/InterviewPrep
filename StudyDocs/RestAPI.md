### What is REST?
**REST** (Representational State Transfer) is an architectural style for designing networked applications. It relies on a stateless, client-server communication protocol, typically HTTP.
**Easy to Remember**: REST = **R**esource-centric, **E**asy communication, **S**tateless, **T**ransfer over HTTP.

### What Are the Key Concepts in Designing RESTful API?
1. **Resources**: Represent data or functionality.
2. **URIs**: Identify resources.
3. **HTTP Methods**: Define actions (GET, POST, PUT, DELETE).
4. **Statelessness**: Each request is independent.
5. **Representation**: Data format (JSON, XML).
6. **HATEOAS**: Hypermedia As The Engine Of Application State.
**Easy to Remember**: **R**esource, **U**RI, **M**ethods, **S**tateless, **R**epresentation, **H**ATEOAS.

### What Are the Best Practices of RESTful Services?
1. Use **nouns** for URIs (e.g., `/users`).
2. Stick to **HTTP methods** for actions.
3. Handle **errors with appropriate HTTP status codes**.
4. Make services **stateless**.
5. Use **HATEOAS** for links to related resources.
6. Provide **pagination** for large datasets.
**Easy to Remember**: **N**ouns for URIs, **M**ethods for actions, **S**tatus codes, **S**tateless, **H**ATEOAS, **P**agination.

### Can You Show the Code for an Example Get Resource Method with Spring REST?
```java
@GetMapping("/users/{id}")
public ResponseEntity<User> getUserById(@PathVariable Long id) {
    User user = userService.findById(id);
    return ResponseEntity.ok(user);
}
```
**Easy to Remember**: Use `@GetMapping` for GET requests.

### What Happens When We Return a Bean from a Request Mapping Method?
The bean is automatically **serialized** into the specified format (e.g., JSON, XML) and sent as the HTTP response body.
**Easy to Remember**: Bean -> **JSON/XML** -> HTTP Response.

### What is GetMapping and What Are the Related Methods Available in Spring MVC?
`@GetMapping` is a shortcut for `@RequestMapping(method = RequestMethod.GET)`. Related methods include:
- `@PostMapping`
- `@PutMapping`
- `@DeleteMapping`
- `@PatchMapping`
**Easy to Remember**: **Get, Post, Put, Delete** mappings for CRUD operations.

### Can You Show the Code for an Example Post Resource Method with Spring REST?
```java
@PostMapping("/users")
public ResponseEntity<User> createUser(@RequestBody User user) {
    User savedUser = userService.save(user);
    return ResponseEntity.status(HttpStatus.CREATED).body(savedUser);
}
```
**Easy to Remember**: Use `@PostMapping` for creating resources.

### What Is the Appropriate HTTP Response Status for Successful Execution of a Resource Creation?
**201 Created**.
**Easy to Remember**: Resource created = **201**.

### Why Do We Use ResponseEntity in a RESTful Service?
`ResponseEntity` allows you to control the **HTTP status**, **headers**, and **body** of the response, providing more flexibility.
**Easy to Remember**: **Control** everything about the response.

### What Is HATEOAS?
**HATEOAS** stands for **H**ypermedia **A**s **T**he **E**ngine **O**f **A**pplication **S**tate. It provides links to related resources in the response, allowing clients to navigate the API dynamically.
**Easy to Remember**: HATEOAS = **L**inks in responses.

### Can You Give an Example Response for HATEOAS?
```json
{
    "id": 1,
    "name": "John Doe",
    "links": [
        {"rel": "self", "href": "/users/1"},
        {"rel": "orders", "href": "/users/1/orders"}
    ]
}
```
**Easy to Remember**: Provide **self** and **related** links.

### How Do We Implement HATEOAS Using Spring?
Use the `EntityModel` or `CollectionModel` classes from Spring HATEOAS to add links to your resources.
**Easy to Remember**: Use `EntityModel` for **one** resource, `CollectionModel` for **many**.

### How Do You Document RESTful Web Services?
Use **Swagger** (OpenAPI) for automated documentation, or manually create API docs.
**Easy to Remember**: **Swagger** = **Auto** documentation.

### Can You Give a Brief Idea About Swagger Documentation?
Swagger provides a UI and JSON/YAML specification to interact with and document your APIs, generated from annotations.
**Easy to Remember**: **Interactive API docs** with Swagger.

### How Do You Automate Generation of Swagger Documentation from RESTful Web Services?
Annotate your controllers with `@Api`, `@ApiOperation`, etc., and use SpringFox or OpenAPI libraries to generate the docs.
**Easy to Remember**: Annotate, Generate.

### How Do You Add Custom Information to Swagger Documentation Generated from RESTful Web Services?
Use annotations like `@ApiParam`, `@ApiResponse`, and configuration classes to customize.
**Easy to Remember**: Annotate with **custom** details.

### What Is Swagger-UI?
**Swagger-UI** is a web interface that allows you to view and interact with the API documentation generated by Swagger.
**Easy to Remember**: Swagger-UI = **Visual** API interaction.

### What Is "Representation" of a Resource?
A **representation** is the specific format (JSON, XML, etc.) in which a resource is returned from a RESTful service.
**Easy to Remember**: Resource **format** = Representation.

### What Is Content Negotiation?
**Content Negotiation** is the process of selecting the appropriate representation format (JSON, XML) based on client preferences.
**Easy to Remember**: Negotiating the **format**.

### Which HTTP Header Is Used for Content Negotiation?
The `Accept` header.
**Easy to Remember**: Client **Accepts** the format.

### How Do We Implement Content Negotiation Using Spring Boot?
Use the `ContentNegotiationConfigurer` and configure supported media types in your application.
**Easy to Remember**: Configure **content** options.

### How Do You Add XML Support to Your RESTful Services Built with Spring Boot?
Include `Jackson` or `JAXB` dependencies and configure `MessageConverters` to support XML.
**Easy to Remember**: Add **dependencies** and **configure**.

### How Do You Implement Exception Handling for RESTFul Web Services?
Use `@ControllerAdvice` and `@ExceptionHandler` annotations to globally manage exceptions.
**Easy to Remember**: **Advice** for handling exceptions.

### What Are the Best Practices Related to Exception Handling with Respect to RESTful Web Services?
1. Use **meaningful** status codes (e.g., 404 for not found).
2. Provide **detailed error messages**.
3. Implement a **global exception handler**.
**Easy to Remember**: **Codes**, **Messages**, **Global Handler**.

### What Are the Different Error Statuses That You Would Return in RESTful Web Services?
- **400 Bad Request**: Client error.
- **401 Unauthorized**: Authentication needed.
- **403 Forbidden**: Access denied.
- **404 Not Found**: Resource not found.
- **500 Internal Server Error**: Server-side issue.
**Easy to Remember**: **4xx** for client errors, **5xx** for server errors.

### How Would You Implement Them Using Spring Boot?
Use `@ResponseStatus` on custom exceptions or configure them in `@ControllerAdvice`.
**Easy to Remember**: **Status codes** with exceptions.

### What HTTP Response Status Do You Return for Validation Errors?
**400 Bad Request**.
**Easy to Remember**: Validation = **Client** error = **400**.

### How Do You Handle Validation Errors with RESTful Web Services?
Use `@Valid` on request parameters and handle the validation errors with `BindingResult` and `@ExceptionHandler`.
**Easy to Remember**: Validate with `@Valid`, **catch** errors with `BindingResult`.

### Why Do We Need Versioning for RESTful Web Services?
To manage changes over time without breaking existing clients.
**Easy to Remember**: **Change** management without **breakage**.

### What Are the Versioning Options That Are Available?
1. **URI Versioning**: `/v1/resource`
2. **Query Parameter Versioning**: `/resource?version=1`
3. **Header Versioning**: `Accept: application/vnd.example.v1+json`
4. **Content Negotiation**: Use `Accept` header.
**Easy to Remember**: **U**RI, **Q**uery, **H**eader, **C**ontent (UQHC).

### How Do You Implement Versioning for RESTful Web Services?
Choose a strategy (e.g., URI, Header) and configure your controllers accordingly.
**Easy to Remember**: Pick a **versioning** method and implement.


### **JWT vs OAuth: Which is Used for Authorization?**

#### **1. JWT (JSON Web Token):**
- **JWT** is a token format. It is **not a protocol** but is widely used in **authorization** systems.
- A JWT contains encoded JSON data, which can include:
  - Claims about the user (e.g., roles, permissions).
  - Information about the issuer and the expiration time.

---

#### **How JWT is Used for Authorization:**
1. **Authentication Phase**:
   - A user logs in and provides valid credentials.
   - The server generates a JWT containing user-specific claims (e.g., roles, user ID).
   - The client receives and stores this token (e.g., in local storage or cookies).

2. **Authorization Phase**:
   - The client sends the JWT with every subsequent request (usually in the `Authorization` header as `Bearer <token>`).
   - The server verifies the JWT:
     - Validates the signature.
     - Decodes the token to check claims.
     - If the user has the required claims (e.g., roles/permissions), the server authorizes access to the resource.

---

#### **2. OAuth:**
- **OAuth** is an authorization framework (protocol) that allows applications to delegate user authorization to a third-party service (e.g., Google, Facebook).
- OAuth provides access tokens to allow secure access to protected resources without exposing the user's credentials.

---

#### **How OAuth is Used for Authorization:**
1. **Resource Owner Authorization**:
   - A user (resource owner) logs in to a third-party service (e.g., Google).
   - The service prompts the user to approve the application's access to certain resources (e.g., email, profile).

2. **Access Token Generation**:
   - Upon approval, the OAuth server generates an **access token** and sends it back to the application.
   - This token usually has an expiration time and limited scope (permissions).

3. **Resource Access**:
   - The application uses the access token to call APIs on behalf of the user.
   - The resource server verifies the token and grants or denies access based on the token's scope.

---

### **Key Differences**
| Feature               | JWT                              | OAuth                                 |
|-----------------------|----------------------------------|---------------------------------------|
| **Purpose**           | Token format for authorization  | Authorization framework              |
| **Scope**             | Used for both authentication and authorization | Focused on authorization             |
| **Usage**             | Stateless, self-contained token | Delegates authorization to a provider|
| **Token Type**        | Encoded JSON token               | Usually access tokens, often opaque  |
| **Authentication**    | Not directly handled            | Often paired with OpenID Connect for authentication |
| **Authorization**     | Claims in the JWT determine access | Access tokens with limited scopes define access |

---

### **High-Level Workflow Comparison**

#### **JWT-Based Authorization**
1. User logs in → Server generates a JWT.
2. JWT is sent with each request → Server verifies and authorizes based on token claims.
3. JWT is stateless → No need to store session data on the server.

#### **OAuth-Based Authorization**
1. Application redirects user to an OAuth provider for login.
2. User approves access → OAuth provider issues an **access token**.
3. Application uses the access token to access the user's resources on behalf of the user.

---

### **When to Use What**
- **Use JWT**:
  - When you want a simple, stateless system for both authentication and authorization.
  - For microservices where tokens need to pass claims directly.
  - If you're building a custom authentication system.

- **Use OAuth**:
  - When you need delegated authorization (e.g., "Login with Google").
  - When accessing third-party APIs securely.
  - For applications requiring complex scopes and granular resource permissions.

---

### **Common Integration**
Often, OAuth issues access tokens as JWTs. In such cases:
- **OAuth manages authorization**, including token issuance and scopes.
- **JWT provides the token format**, making it easy to decode and validate token claims.

Let me know if you’d like more in-depth examples or clarification!